学习笔记

### 串行/并行/G1 案例演练

|  | SerialGC | ParallelGC | G1GC |
| --- | --- | --- | --- |
| 256M | 4316（21次GC，14次Full GC） | 3310（22次GC，13次Full GC） | 3549(111次GC，19次Full GC) |
| 512M | 7073(12次GC，3次FullGC) | 6420(19次GC，4次Full GC) | 8265(56次GC，1次FullGC)  |
| 1G | 9541(6次GC) | 9972(11次GC，1次FullGC)  | 10599 (25次GC) |
| 2G | 11062(3次GC) | 13143(4次GC) | 11840(13次GC) |
| 4G | 10290 | 13084（1次GC） | 11633（11次GC） |

大致的可以看出来了，当堆内存很小的时候，SerialGC算法会更高效一些，但是随着堆内存大小的增加，ParallelGC 的表现就变得更为高效。此外，当堆内存设置为4G时，程序运行的时间调整为5秒后，G1GC的表现就变得更为高效。

所以也侧面印证了课上所说的，当堆内存只有1G左右时，使用ParallelGC即可，只有当堆内存超过1G时，更推荐使用G1GC。


### 串行/并行/G1 差异
SerialGC: 单线程垃圾收集器，新生代采取标记-复制算法，老年代采取标记-整理算法，有点简单高效，在单CPU环境下有更高的垃圾回收效率

Parallel GC：多线程垃圾收集器，新生代为Parallel Scavenge 垃圾回收器，采取了标记-复制的算法，老年代采取标记-整理的算法，为了使得JVM达到一个可控制的吞吐量而设计的

G1GC：将堆内存分割为1024个region，来取代原来的分代的设计，适用于有足够大的堆内存可用的生产环境